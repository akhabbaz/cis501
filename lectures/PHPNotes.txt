Chapter 2


Symbol table 
matches labels to addresses.  Contains a pair of symbol and addresses of the
memory words that instructions occupy.

relocation information: identifies instructions and data words that depend on
absolute addresses.

   
instruction format:
  R   op (6 b), rs(5 b), rt(5 b), rd(5 bits), shamt (5),   funct(6) 
  I   op (6 b), rs(5 b), rt(5 b),  const (16 bits)
  J   op (6 b), const (26 bits)
  t0   register 8  temporary registers
  s0,s7   16 variables
  v0, v1   2,3 function return values
figure A.6.1 describes registers and usage.  

command	format	op	rs	rt	rd	shamt	funct	const
add	R	0	0-31	0-31	0-31	0	32	na
sub	R	0	0-31	0-31	0-31	0	34	na
addi	I	8	0-31	0-31	na	na	na	-2**15 -> 2**(15)-1
lw	I	35	0-31	0-31	na	na	na	-2**15 -> 2**(15)-1
sw	I	35	0-31	0-31	na	na	na	-2**15 -> 2**(15)-1

all values in table are decimal.
The destination or answer is in rd for add, sub, and rt for addi, lw, sw.
lw uses an offset that can be negative.  Thus it is sign extended.  Also this is
byte addressable, and not word addressable.

Useful instructions
branches jumps
bne  $s0, S1, label # format I, $s0 != $s1  goto label; label is a 16 bit word
		    # address that is added to PC + 4, opcode 5
beq  $s0, S1, label # format I, $s0 == $s1  goto label; label is a 16 bit word
		    # address
j    Label          # format J, word address, lower 26 bits from label, upper 4
		    # from PC. label must be within 256 MB or 64 million
		    # instructions away. jump to label
jal    Label        # format J, word address, lower 28 bits from label, upper 4
		    # from PC. label must be within 256 MB or 64 million
		    # instructions away. jump to label and store current pc+4 in
		    # register $ra.
jr   $ra            # not sure format but could be I, anyway next pc is from
		    # register $ra.

comparisons
slti  $t0, $s2, 10  # format I ; $t0 = 1 if $s2 < 10
slt   $t0, $s2, $s1 # format R ; $t0 = 1 if $s2 < $s1
sltu  $t0, $s2, $s1 # format R ; $t0 = 1 if $s2 < $s1 unsigned comparison
constants
lui  $s0, 61,       # load upper 16 bits of $s0 with constant and fill lower 16
		    # bits with 0s.
load bytes:
lb, $t0, 0($sp)     # read a byte from source puts it into rightmost 8 bit of a
		    # register. Then it sign extends the byte.  format I
lbu, $t0, 0($sp)    # load a byte but this time set the upper bits to zero.
sb, $t0, 0($gp)     # store a byte from source, format I
