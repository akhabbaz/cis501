Here is the example of a recursive program in MIPS  from 2.8 Patterson and Hennesy


fact:   slti   $t0, $a0, 1   #  test if ao < 1 
          bne $t0, $zero,   Over    # if Over end
          #  now store $ra, $a0 on stack
   3    addi  $sp, $sp, -8     #  store ra, a0 on stack
   4     sw    $a0,   0($sp) 
   5     sw    $ra,    4($sp)
          addi   $a0, $a0, -1   
          jal     fact       # call fact recursively
          lw      $a0  0($sp)
          lw       $ra  4($sp)
          addi      $sp, $sp, 8   # restore stack
          mult      $vo, $vo, $a0
           jr          $ra
    





Over:  addi $v0,  $zero, 1     #this routine is one
           jr      $ra


This was nearly perfect.   Only issue was sw, lw were reversed.  P+H also put instr 3-5 before bne




2.8  Next example:

accumulator


  loop:    slti   $t0, $zero, $a0
              beq  $t0, $zero,  endL
              addi $a1, $a1, $a0
              addi $a0, $a0, -1
              j  Loop




endL:      add  $v0,  $a1, $zero
            jr       $ra

works fin


StrCopy

2.9

# #a0  is x[]  #a1 is y[]

   
 	addi  $sp, $sp, -4   #  make room on stack for s0
        sw    $s0  0($sp)    #   exercise in keeping using stack could 
			     #   store in $t0
              add  $s0, $zero, $zero  # initialize $s0
Loop:  add    $t1  $s0, $a1   get index of byte in memory. no x4 multiply byte 
       lbu    $t2   0($t1) 
       add    $t3  $s0, $a0
       sbu    $t2   $0($t3)
       beq    $t2, $zero, exit
       addi   $s0, $s0, 1
       j      Loop


exit:   lw     $s0, 0($sp)
       addi   $sp, $sp, 4
       jr     $ra

This one got the idea but forgot return statement



Constants


load an immediate constant into register s0


lui    $s0,      61   # puts zeros in the lower register
ori   $s0, $s0,    2304    

Here we don't want addi because that does sign extension.  We want ori because
that does not do sign extension.




Loop in machine language:


Loop:  sll $t1, $s3, 2     # temp reg $t1 = 4* i  
       add $t1, $t1, $s6   # $t1 = address of save[i]
       lw  $t0, 0($t1)     # temp = reg $t[ = save[i] 
       bne $t0, $s5, EXit  # go to Exit if save[i] not equal to k
       addi $s3,  $s3, 1   # i = i + 1
       j   Loop
Exit :


instruction format:
  R   op (6 b), rs(5 b), rt(5 b), rd(5 bits), shamt (5),   funct(6) 
  I   op (6 b), rs(5 b), rt(5 b),  const (16 bits)
  J   op (6 b), const (26 bits)
  t0   8
  s0   16

80000:R, 0, 0  , 19  , 9, 2, 0
80004:R, 0, 9, 22, 9, 0, 32
80008:I, 35, 9, 8, 0
80012:I, 5, 8, 21, 2  #  rs, rt destination, 8 is Exit - (pc + 4)
80016:I, 8, 19, 19, 1
80020:J, 20000
80024:.....
8000   0,     


code:  bne   rs, rt,  
the counting for branches and jumps use word not bytes so addresses are 4 times
smaller 



Check yourself
:   2.10

1 conditional branches have 16 bits or 64K states.  jumps are written in 4 byte
increments so that gets you to 256K.  Half are positive half negative therefore
answer 4 is correct.


2.  Similar reasoning.  Now we have 256 M instead of 256 K.  Number 4 is
correct.

3.  SLL from the table. 





Dynamically linked libraries.

My understanding. Figure 2.22

(a)  Start out at the top.  jal loads a procedure.  get to lw  and that points
to a data location.  Now that data is non local so it goes to a linked list of
nonlocal data. This code (text) puts a number in a register that identifies the
appropriate library routine. This then jumps to the dynamic linker/loader code.
This linker loader finds the desired routine and then remaps it and changes the
address of the indirect jump.  When the DLL completes it jr to the original
code.  Next time the indirect location is mapped (the address is changed in the
loaded code so next time the dynamic linker does not need to be called and the
return address jr is correct to get back to the original code.
a dynamic linker/loader routine



2.22 Exercises:


2.1
let 

$s0-2   f, g, h respectively

addi $t0, $s2, -5   # h-5,  -5 = 0xFFF11
add, $s0, $s1, $t0   # add $t0 + g
2.2

f = i + g + h

2.3

sub $t0, $s3, $s4  # $t0 = i -j
addi $t1, $zero, 4 # put 4 in a register
sll  $t1, $t0, 4   # $t1 = 4 (i -j)
add $t2, $s6,  $ti   # compute address of the data 
lw   $t2, 0($t1) # load A[$t1] in $t1
sw   $t2, 32($s7) # store $t1 is B[8]


2.4

B[g] = A[f] + A[f+1]
2.5

I can't see how to reduce the set of instructions for this command.
The first 4 instructions basically get &A[f] and &B[g]. Instr 5 loads A[f].


Ok  Here is a way to reduce the number of instructions.

sll $t0, $s0, 2
add $t0, $s6, $t0  # $t0 = &A[f]
sll $t1, $s1, 2
add $t1, $s7, $t1  # $t1 = &B[g]
lw  $s0, 0($t0)    # f = A[f]
lw  $t2, 4($t0)    # $t2 = A[f+1]  # Here is where we save an instruction. This
		   # was two instructions previously.  Lw has room for an
		   # address, the 4 in this case. $t2 is free.
add $t0, $t2, $s0  # $t0 = A[f] + A[f+1]
sw  $t0, 0($t1)    # B[g] = A[f] + A[f+1]
  

2.6

1. C code to sort an array
// this version uses that temp holds the new unsorted value; this saves time
// because the swap only has to transfer the old value up one; each j loop skips
// instruction A[j] = temp.   Also temp gets
// loaded once per i loop, not once per j loop.  The while breaks the j loop
// once temp is greater than or equal Array[j], so on average saves steps. 
const int length = 5; # $a1
int  Array[] = {2, 4, 3, 6, 1}; #Array   $a0

for (int i = 1; i < length; i++) {
         int j = i -1;
         int temp = Array[i];
         while ( j >= 0 && temp < Array[j]) {
                  Array[j + 1] = Array[j];
                  // Array[j] = temp is skipped each loop.
                  j = j -1;
		}
         Array[j+1] = temp;// in all cases put back temp into array
         }
}

This code uses branches etc.  It requires branches taught in later sections.

int A[] = {2, 4, 3, 6, 1}
1.  int last  = A[4];
2.       A[4] = A[3];
3.       A[3] = A[1];
4.       A[1] = A[0];
5.       A[0] = last;

2.6.2

let A = $s6

lw  $t0, 16($s6) // 1.   
lw  $t1, 12($s6) // 2.
sw  $t1, 16($s6) // 2.
lw  $t1, 4($s6)  // 3.
sw  $t1, 12($s6)  // 3. 
lw  $t1, 0($s6)  // 4.
sw  $t1, 4($s6)  // 4
sw  $t0, 0($s6)  // 5.

2.7

value 0xabcdef12
little Endian
address	byte
0	12
1	ef
2	cd
3	ab
lowest byte 0 has smallest value

Big Endian
address	byte
0	ab
1	cd
2	ef
3	12
Here you can read the value starting at the lowest address.  Mips is Big Endian.
Little Endian has an advantage for casts. For example if you want only 16 bits,
0x ef12,
in little Endian you would need only to take the first 16 bits in address 0, 1.
In Big Endian you would need to move bytes 2, 3 into a new location. 

2.8 translate 0xabcdef12 into decimal.

number is 

digit	Power16	hexdigit
2	0	2
1	1	1
15	2	f
14	3	e
13	4	d
12	5	c
11	6	b
10	7	a
2882400018  in decimal.  Used calculator for product above.  Also converted with
hex function.

2.9

translate B[8] = A[i] + A[j]
f, g, h, i, j,  are in $s0, $s1, $s2, $s3, $s4
A, B are in $s6, $s7
sll  $t0, $s4, 2  // j*4
add  $t1, $s6, $t0  // addr A[j]
lw   $t2, 0($t1)    // A[j]
sll  $t0, $s3, 2    // i*4
add  $t1, $s6, $t0  // addr A[i]
lw   $t3, 0($t1)   // A[i]
add  $t0, $t3, $t2  // A[i] + A[j]
sw   $t0, 32($s7)  // B[8] = A[i] + A[j]

2.10

f, g, h, i, j,  are in $s0, $s1, $s2, $s3, $s4
A, B are in $s6, $s7
MIPS code

addi 	$t0, $s6, 4 // $t0 = &A[1]
add 	$t1, $s6, $0 // $t1 = &A[0]
sw  	$t1, 0($t0)  // A[1] = &A[0]
lw  	$t0, 0($t0)  // $t0 = &A[0]
add	$s0, $t1, $t0

doesn't make too much sense because  $t1, $t0 are both &A[0]
f = 2*(&A);  this is the code
            
2.11

For each instruction what is the value of the field?
   
instruction format:
  R   op (6 b), rs(5 b), rt(5 b), rd(5 bits), shamt (5),   funct(6) 
  I   op (6 b), rs(5 b), rt(5 b),  const (16 bits)
  J   op (6 b), const (26 bits)
  t0   8
  s0   16

command	format	op	rs	rt	rd	shamt	funct	const
add	R	0	0-31	0-31	0-31	0	32	na
sub	R	0	0-31	0-31	0-31	0	34	na
addi	I	8	0-31	0-31	na	na	na	-2**15 -> 2**(15)-1
lw	I	35	0-31	0-31	na	na	na	-2**15 -> 2**(15)-1
sw	I	35	0-31	0-31	na	na	na	-2**15 -> 2**(15)-1

all values in table are decimal
.
